// <auto-generated/>
namespace SteganographyApp
{
    using System.Collections.Immutable;
    using System.Text.Json;

    using SteganographyApp.Common.Arguments;
    using SteganographyApp.Common.Injection;
    using SteganographyApp.Common.Logging;

    [ProgramDescriptor("Encode a file to the specified cover images.")]
    public sealed class EncodeArguments : IArgumentConverter
    {
        [Argument("--coverImages", "-c", true, helpText: "The images where the input file will be encoded and written to.")]
        public ImmutableArray<string> CoverImages = new ImmutableArray<string>();

        [Argument("--password", "-p", helpText: "The optional password used to encrypt the input file contents.")]
        public string Password = string.Empty;

        [Argument("--file", "-f", true, helpText: "The path to the file to encode and write to the cover images.", parser: nameof(ParseFilePath))]
        public string InputFile = string.Empty;

        [Argument("--randomSeed", "-r", helpText: "The optional value to determine how the contents of the input file will be randomized before writing them.")]
        public string RandomSeed = string.Empty;

        [Argument("--dummyCount", "-d", helpText: "The number of dummy entries that should be inserted after compression and before randomization. Recommended value between 100 and 1,000")]
        public int DummyCount = 0;

        [Argument("--chunkByteSize", "-cs", helpText: "The number of bytes to read and encode from the input file during each iteration.")]
        public int ChunkByteSize = 524_288;

        [Argument("--logLevel", "-l", helpText: "The log level to determine which logs will feed into the log file.")]
        public LogLevel LogLevel = LogLevel.None;

        [Argument("--additionalHashes", "-a", helpText: "The number of additional times to hash the password. Has no effect if no password is provided.")]
        public int AdditionalPasswordHashIterations = 0;

        [Argument("--compress", "-co", helpText: "If provided will compress the contents of the file before encryption.")]
        public bool EnableCompression = false;

        public static object ParseFilePath(object? target, string value) => ParserFunctions.ParseFilePath(value);

        public IInputArguments ToCommonArguments()
        {
            RootLogger.Instance.EnableLoggingAtLevel(LogLevel);
            var arguments = new CommonArguments
            {
                CoverImages = CoverImages,
                Password = Password,
                FileToEncode = InputFile,
                RandomSeed = RandomSeed,
                ChunkByteSize = ChunkByteSize,
                DummyCount = DummyCount,
                AdditionalPasswordHashIterations = AdditionalPasswordHashIterations,
                UseCompression = EnableCompression,
            };
            Injector.LoggerFor<EncodeArguments>().Debug("Using input arguments: [{0}]", () => new[] { JsonSerializer.Serialize(arguments) });
            return arguments;
        }
    }
}