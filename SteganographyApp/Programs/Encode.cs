// <auto-generated/>
namespace SteganographyApp;

using System;
using System.Collections.Immutable;
using System.Text.Json;

using SteganographyApp.Common;
using SteganographyApp.Common.Arguments;
using SteganographyApp.Common.Arguments.Commands;
using SteganographyApp.Common.Arguments.Validation;
using SteganographyApp.Common.Injection;
using SteganographyApp.Common.IO;
using SteganographyApp.Common.IO.Content;
using SteganographyApp.Common.Logging;

[ProgramDescriptor(
    "Encode an input file and hide it within a series of cover images.",
    "dotnet SteganographyApp.dll encode -c *.png,*.webp -f input.zip -p testing -r 123 -d 300 -a 30 -l Debug"
)]
internal sealed class EncodeArguments : IArgumentConverter
{
    [Argument(
        "--coverImages",
        "-c",
        true,
        helpText: "The images where the input file will be encoded and hidden within."
            + " This parameter can be a comma delimited list of globs with the current directory as the root directory from which files will be matched.",
        example: "*.png,*.webp"
    )]
    public ImmutableArray<string> CoverImages = [];

    [Argument("--password", "-p", helpText: "The optional password used to encrypt the input file contents. Providing a question mark (?) as input allows this parameter to be entered in an interactive mode where the input will be captured but not displayed.")]
    public string Password = string.Empty;

    [Argument("--file", "-f", true, helpText: "The path to the file to encode and write to the cover images.")]
    [IsFile]
    public string InputFile = string.Empty;

    [Argument("--randomSeed", "-r", helpText: "The optional value to determine how the contents of the input file will be randomized before writing them. Providing a question mark (?) as input allows this parameter to be entered in an interactive mode where the input will be captured but not displayed.")]
    public string RandomSeed = string.Empty;

    [Argument("--dummyCount", "-d", helpText: "The number of dummy entries that should be inserted after compression and before randomization. Recommended value between 100 and 1,000. Providing a question mark (?) as input allows this parameter to be entered in an interactive mode where the input will be captured but not displayed.")]
    [InRange(0, int.MaxValue)]
    public int DummyCount = 0;

    [Argument("--chunkByteSize", "-cs", helpText: "The number of bytes to read and encode from the input file during each iteration.")]
    [InRange(1, int.MaxValue)]
    public int ChunkByteSize = 524_288;

    [Argument("--logLevel", "-l", helpText: "The log level to determine which logs will feed into the log file.")]
    public LogLevel LogLevel = LogLevel.None;

    [Argument("--additionalHashes", "-a", helpText: "The number of additional times to hash the password. Has no effect if no password is provided. Providing a question mark (?) as input allows this parameter to be entered in an interactive mode where the input will be captured but not displayed.")]
    [InRange(0, int.MaxValue)]
    public int AdditionalPasswordHashIterations = 0;

    [Argument("--compress", "-co", helpText: "If provided will compress the contents of the file after encryption.")]
    public bool EnableCompression = false;

    [Argument("--twoBits", "-tb", helpText: "If true will store data in the least and second-least significant bit rather than just the least significant.")]
    public bool TwoBits = false;

    public IInputArguments ToCommonArguments()
    {
        RootLogger.Instance.EnableLoggingAtLevel(LogLevel);
        var arguments = new CommonArguments
        {
            CoverImages = CoverImages,
            Password = Password,
            FileToEncode = InputFile,
            RandomSeed = RandomSeed,
            ChunkByteSize = ChunkByteSize,
            DummyCount = DummyCount,
            AdditionalPasswordHashIterations = AdditionalPasswordHashIterations,
            UseCompression = EnableCompression,
            BitsToUse = TwoBits ? 2 : 1,
        };
        Injector.LoggerFor<EncodeArguments>().Debug("Using input arguments: [{0}]", () => new[] { JsonSerializer.Serialize(arguments) });
        return arguments;
    }
}

internal sealed class EncodeCommand : Command<EncodeArguments>
{
    private readonly ILogger log = new LazyLogger<EncodeCommand>();

    public override string GetName() => "encode";

    public override void Execute(EncodeArguments args)
    {
        var arguments = args.ToCommonArguments();
        Console.WriteLine("Encoding File: {0}", arguments.FileToEncode);

        var utilities = new EncodingUtilities(arguments);

        Encode(utilities, arguments);

        Cleanup(utilities, arguments);
    }

    private void Encode(EncodingUtilities utilities, IInputArguments arguments)
    {
        using (var stream = utilities.ImageStore.OpenStream(StreamMode.Write))
        {
            log.Debug("Encoding file: [{0}]", arguments.FileToEncode);
            int startingPixel = Calculator.CalculateRequiredBitsForContentTable(arguments.FileToEncode, arguments.ChunkByteSize);
            log.Debug("Content chunk table requires [{0}] bits of space to store.", startingPixel);
            stream.SeekToPixel(startingPixel);

            int requiredNumberOfWrites = Calculator.CalculateRequiredNumberOfWrites(arguments.FileToEncode, arguments.ChunkByteSize);
            log.Debug("File requires [{0}] iterations to encode.", requiredNumberOfWrites);
            var progressTracker = ProgressTracker.CreateAndDisplay(requiredNumberOfWrites, "Encoding file contents", "All input file contents have been encoded.");

            using (var reader = new ContentReader(arguments))
            {
                string? contentChunk = string.Empty;
                while (true)
                {
                    log.Debug("===== ===== ===== Begin Encoding Iteration ===== ===== =====");
                    contentChunk = reader.ReadContentChunkFromFile();
                    if (contentChunk == null)
                    {
                        break;
                    }
                    log.Debug("Processing chunk of [{0}] bits.", contentChunk.Length);
                    stream.WriteContentChunkToImage(contentChunk);
                    progressTracker.UpdateAndDisplayProgress();
                    log.Debug("===== ===== ===== End Encoding Iteration ===== ===== =====");
                }
            }
        }
    }

    private void Cleanup(EncodingUtilities utilities, IInputArguments arguments)
    {
        Console.WriteLine("Writing content chunk table.");
        using (var writer = new ChunkTableWriter(utilities.ImageStore))
        {
            writer.WriteContentChunkTable(utilities.TableTracker.GetContentTable());
        }
        Console.WriteLine("Encoding process complete.");
        log.Trace("Encoding process complete.");
        utilities.ImageTracker.PrintImagesUtilized();
    }
}

internal sealed class EncodingUtilities
{
    public EncodingUtilities(IInputArguments args)
    {
        ImageStore = new ImageStore(args);
        TableTracker = new TableChunkTracker(ImageStore);
        ImageTracker = new ImageTracker(args, ImageStore);
    }

    public ImageStore ImageStore { get; }

    public TableChunkTracker TableTracker { get; }

    public ImageTracker ImageTracker { get; }
}