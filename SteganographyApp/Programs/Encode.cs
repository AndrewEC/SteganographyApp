// <auto-generated/>
namespace SteganographyApp
{
    using System;
    using System.Collections.Immutable;
    using System.Text.Json;

    using SteganographyApp.Common;
    using SteganographyApp.Common.Arguments;
    using SteganographyApp.Common.Arguments.Commands;
    using SteganographyApp.Common.Injection;
    using SteganographyApp.Common.IO;
    using SteganographyApp.Common.Logging;

    [ProgramDescriptor("Encode an input file and hide it within a series of cover images.")]
    internal sealed class EncodeArguments : IArgumentConverter
    {
        [Argument("--coverImages", "-c", true, helpText: "The images where the input file will be encoded and hidden within."
            + " This parameter can be a comma delimited list of globs with the current directory as the root directory from which files will be matched.", example: "*.png,*.webp")]
        public ImmutableArray<string> CoverImages = new ImmutableArray<string>();

        [Argument("--password", "-p", helpText: "The optional password used to encrypt the input file contents.")]
        public string Password = string.Empty;

        [Argument("--file", "-f", true, helpText: "The path to the file to encode and write to the cover images.", parser: nameof(ParseFilePath))]
        public string InputFile = string.Empty;

        [Argument("--randomSeed", "-r", helpText: "The optional value to determine how the contents of the input file will be randomized before writing them.")]
        public string RandomSeed = string.Empty;

        [Argument("--dummyCount", "-d", helpText: "The number of dummy entries that should be inserted after compression and before randomization. Recommended value between 100 and 1,000")]
        public int DummyCount = 0;

        [Argument("--chunkByteSize", "-cs", helpText: "The number of bytes to read and encode from the input file during each iteration.")]
        public int ChunkByteSize = 524_288;

        [Argument("--logLevel", "-l", helpText: "The log level to determine which logs will feed into the log file.")]
        public LogLevel LogLevel = LogLevel.None;

        [Argument("--additionalHashes", "-a", helpText: "The number of additional times to hash the password. Has no effect if no password is provided.")]
        public int AdditionalPasswordHashIterations = 0;

        [Argument("--compress", "-co", helpText: "If provided will compress the contents of the file before encryption.")]
        public bool EnableCompression = false;

        [Argument("--twoBits", "-tb", helpText: "If true will store data in the least and second-least significant bit rather than just the least significant.")]
        public bool TwoBits = false;

        public static object ParseFilePath(object? target, string value) => ParserFunctions.ParseFilePath(value);

        public IInputArguments ToCommonArguments()
        {
            RootLogger.Instance.EnableLoggingAtLevel(LogLevel);
            var arguments = new CommonArguments
            {
                CoverImages = CoverImages,
                Password = Password,
                FileToEncode = InputFile,
                RandomSeed = RandomSeed,
                ChunkByteSize = ChunkByteSize,
                DummyCount = DummyCount,
                AdditionalPasswordHashIterations = AdditionalPasswordHashIterations,
                UseCompression = EnableCompression,
                BitsToUse = TwoBits ? 2 : 1,
            };
            Injector.LoggerFor<EncodeArguments>().Debug("Using input arguments: [{0}]", () => new[] { JsonSerializer.Serialize(arguments) });
            return arguments;
        }
    }

    internal sealed class EncodeCommand : BaseCommand<EncodeArguments>
    {
        private readonly ILogger log = new LazyLogger<EncodeCommand>();

        public override string GetName() => "encode";

        public override void Execute(EncodeArguments args)
        {
            var arguments = args.ToCommonArguments();
            Console.WriteLine("Encoding File: {0}", arguments.FileToEncode);

            var utilities = new EncodingUtilities(arguments);

            Encode(utilities, arguments);

            Cleanup(utilities, arguments);
        }

        private void Encode(EncodingUtilities utilities, IInputArguments arguments)
        {
            using (var wrapper = utilities.ImageStore.CreateIOWrapper())
            {
                log.Debug("Encoding file: [{0}]", arguments.FileToEncode);
                int startingPixel = Calculator.CalculateRequiredBitsForContentTable(arguments.FileToEncode, arguments.ChunkByteSize);
                log.Debug("Content chunk table requires [{0}] bits of space to store.", startingPixel);
                wrapper.SeekToPixel(startingPixel);

                int requiredNumberOfWrites = Calculator.CalculateRequiredNumberOfWrites(arguments.FileToEncode, arguments.ChunkByteSize);
                log.Debug("File requires [{0}] iterations to encode.", requiredNumberOfWrites);
                var progressTracker = ProgressTracker.CreateAndDisplay(requiredNumberOfWrites, "Encoding file contents", "All input file contents have been encoded.");

                using (var reader = new ContentReader(arguments))
                {
                    string? contentChunk = string.Empty;
                    while (true)
                    {
                        log.Debug("===== ===== ===== Begin Encoding Iteration ===== ===== =====");
                        contentChunk = reader.ReadContentChunkFromFile();
                        if (contentChunk == null)
                        {
                            break;
                        }
                        log.Debug("Processing chunk of [{0}] bits.", contentChunk.Length);
                        wrapper.WriteContentChunkToImage(contentChunk);
                        progressTracker.UpdateAndDisplayProgress();
                        log.Debug("===== ===== ===== End Encoding Iteration ===== ===== =====");
                    }
                }
                wrapper.EncodeComplete();
            }
        }

        private void Cleanup(EncodingUtilities utilities, IInputArguments arguments)
        {
            Console.WriteLine("Writing content chunk table.");
            using (var writer = new ChunkTableWriter(utilities.ImageStore, arguments))
            {
                writer.WriteContentChunkTable(utilities.TableTracker.GetContentTable());
            }
            Console.WriteLine("Encoding process complete.");
            log.Trace("Encoding process complete.");
            utilities.ImageTracker.PrintImagesUtilized();
        }
    }

    internal class EncodingUtilities
    {
        public EncodingUtilities(IInputArguments args)
        {
            ImageStore = new ImageStore(args);
            TableTracker = new TableChunkTracker(ImageStore);
            ImageTracker = new ImageTracker(args, ImageStore);
        }

        public ImageStore ImageStore { get; }

        public TableChunkTracker TableTracker { get; }

        public ImageTracker ImageTracker { get; }
    }
}