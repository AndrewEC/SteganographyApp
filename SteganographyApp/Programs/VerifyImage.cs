// <auto-generated/>
namespace SteganographyApp;

using System;
using System.IO;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;

using SteganographyApp.Common;
using SteganographyApp.Common.Arguments;
using SteganographyApp.Common.Arguments.Commands;
using SteganographyApp.Common.IO;
using SteganographyApp.Common.Injection;
using SteganographyApp.Common.Logging;

[ProgramDescriptor(
    "Verify the provided cover images can be safely used for encoding and decoding information."
        + " This works by creating a copy of the image, writing some random data to the image,"
        + " saving those changes, reading data from the image, the confirming the data read matches"
        + " the original data written."
)]
internal sealed class VerifyImagesArguments : IArgumentConverter
{
    [Argument(
        "CoverImages",
        position: 1,
        helpText: "The list of images to verify."
            + " This parameter can be a comma delimited list of globs with the current directory as the root directory from which files will be matched.",
        example: "*.png,*.webp"
    )]
    public ImmutableArray<string> CoverImages = new ImmutableArray<string>();

    [Argument("--logLevel", "-l", helpText: "The log level to determine which logs will feed into the log file.")]
    public LogLevel LogLevel = LogLevel.None;

    public IInputArguments ToCommonArguments()
    {
        RootLogger.Instance.EnableLoggingAtLevel(LogLevel);
        return new CommonArguments
        {
            CoverImages = CoverImages,
        };
    }
}

internal sealed class TempCopy : AbstractDisposable
{
    private readonly ILogger logger = new LazyLogger<TempCopy>();

    public TempCopy(string sourcePath)
    {
        DestinationPath = DetermineCopyPath(sourcePath);
        logger.Debug("Creating temp copy of file [{0}] at [{1}]", sourcePath, DestinationPath);
        File.Copy(sourcePath, DestinationPath);
    }

    public string DestinationPath { get; private set; }

    private string DetermineCopyPath(string sourcePath)
    {
        string absolutePath = Path.GetFullPath(sourcePath);
        string extension = Path.GetExtension(absolutePath);
        return Path.ChangeExtension(absolutePath, ".temp" + extension);
    }

    protected override void Dispose(bool disposing) => RunIfNotDisposed(() => {
        if (!disposing)
        {
            return;
        }
        logger.Debug("Deleting temp file from: [{0}]", DestinationPath);
        File.Delete(DestinationPath);
    });
}

internal sealed class VerifyImagesCommand : Command<VerifyImagesArguments>
{
    private ILogger logger = new LazyLogger<VerifyImagesCommand>();

    public override string GetName() => "verify";

    public override void Execute(VerifyImagesArguments args)
    {
        var arguments = args.ToCommonArguments();
        Console.WriteLine($"Identified [{args.CoverImages.Length}] images to verify.");
        var tracker = ProgressTracker.CreateAndDisplay(arguments.CoverImages.Length, "Verifying image.", "Finished verifying all images.");
        var failedValidation = new List<string>();
        foreach (string path in args.CoverImages)
        {
            Console.WriteLine($"Verifying image: [{path}]");
            string binary = GenerateBinaryString(path);
            using (var copy = new TempCopy(path))
            {
                WriteToImage(copy.DestinationPath, binary, arguments);
                string readBinary = ReadFromImage(copy.DestinationPath, binary, arguments);
                if (binary != readBinary)
                {
                    failedValidation.Add(path);
                }
            }
            tracker.UpdateAndDisplayProgress();
        }
        PrintFailed(failedValidation);
    }

    private void PrintFailed(List<string> failedValidation)
    {
        if (failedValidation.Count == 0)
        {
            Console.WriteLine("Successfully validated all images.");
            return;
        }
        Console.WriteLine("The following images failed validation:");
        foreach (var failed in failedValidation)
        {
            Console.WriteLine($"\t[{failed}]");
        }
    }

    private string GenerateBinaryString(string path)
    {
        using (var image = Injector.Provide<IImageProxy>().LoadImage(path))
        {
            int bitCount = (image.Width * image.Height) / 2;
            logger.Trace("Generating binary string with a length of: [{0}]", bitCount);
            var random = new Random();
            return string.Concat(Enumerable.Range(0, bitCount).Select(i => random.Next(10) % 2 == 0 ? '0' : '1'));
        }
    }

    private void WriteToImage(string path, string binaryData, IInputArguments arguments)
    {
        using (var wrapper = new ImageStore(arguments).CreateIOWrapper())
        {
            wrapper.WriteContentChunkToImage(binaryData);
            wrapper.EncodeComplete();
        }
    }

    private string ReadFromImage(string path, string expectedData, IInputArguments arguments)
    {
        using (var wrapper = new ImageStore(arguments).CreateIOWrapper())
        {
            return wrapper.ReadContentChunkFromImage(expectedData.Length);
        }
    }
}