// <auto-generated/>
namespace SteganographyApp
{
    using System;
    using System.IO;
    using System.Collections.Generic;
    using System.Collections.Immutable;
    using System.Linq;

    using SteganographyApp.Common;
    using SteganographyApp.Common.Arguments;
    using SteganographyApp.Common.Arguments.Commands;
    using SteganographyApp.Common.IO;
    using SteganographyApp.Common.Injection;
    using SteganographyApp.Common.Logging;

    [ProgramDescriptor(
        "Verify the provided cover images can be safely used for encoding and decoding information.\n"
            + "This works by creating a copy of the image, writing some random data to the image,\n"
            + "saving those changes, the re-reading from the image to affirm the data read matches the original written data."
    )]
    internal sealed class VerifyImagesArguments : IArgumentConverter
    {
        [Argument("--coverImages", "-c", position: 1, helpText: "The list of images to verify.")]
        public ImmutableArray<string> CoverImages = new ImmutableArray<string>();

        public IInputArguments ToCommonArguments()
        {
            return new CommonArguments
            {
                CoverImages = CoverImages,
            };
        }
    }

    internal class TempCopy : IDisposable
    {
        private TempCopy(string sourcePath)
        {
            this.DestinationPath = DetermineCopyPath(sourcePath);
        }

        public string DestinationPath
        {
            get;
            private set;
        }

        public static TempCopy Create(string sourcePath)
        {
            var copy = new TempCopy(sourcePath);
            Injector.LoggerFor<TempCopy>().Debug("Creating temp copy of file [{0}] at [{1}]", sourcePath, copy.DestinationPath);
            File.Copy(sourcePath, copy.DestinationPath);
            return copy;
        }

        private string DetermineCopyPath(string sourcePath)
        {
            string absolutePath = Path.GetFullPath(sourcePath);
            string extension = Path.GetExtension(absolutePath);
            return Path.ChangeExtension(absolutePath, ".temp" + extension);
        }

        public void Dispose()
        {
            Injector.LoggerFor<TempCopy>().Debug("Deleting temp file from: [{0}]", DestinationPath);
            File.Delete(DestinationPath);
        }
    }

    internal sealed class VerifyImagesCommand : BaseCommand<VerifyImagesArguments>
    {
        private ILogger logger = new LazyLogger<VerifyImagesCommand>();

        public override string GetName() => "verify";

        public override void Execute(VerifyImagesArguments args)
        {
            var arguments = args.ToCommonArguments();
            Console.WriteLine($"Identified [{args.CoverImages.Length}] images to verify.");
            var tracker = ProgressTracker.CreateAndDisplay(arguments.CoverImages.Length, "Verifying image.", "Finished verifying all images.");
            var failedValidation = new List<string>();
            foreach (string path in args.CoverImages)
            {
                Console.WriteLine($"Verifying image: [{path}]");
                string binary = GenerateBinaryString(path);
                using (var copy = TempCopy.Create(path))
                {
                    WriteToImage(copy.DestinationPath, binary, arguments);
                    string readBinary = ReadFromImage(copy.DestinationPath, binary, arguments);
                    if (binary != readBinary)
                    {
                        failedValidation.Add(path);
                    }
                }
                tracker.UpdateAndDisplayProgress();
            }
            PrintFailed(failedValidation);
        }

        private void PrintFailed(List<string> failedValidation)
        {
            if (failedValidation.Count == 0)
            {
                Console.WriteLine("Successfully validated all images.");
                return;
            }
            Console.WriteLine("The following images failed validation:");
            foreach (var failed in failedValidation)
            {
                Console.WriteLine($"\t[{failed}]");
            }
        }

        private string GenerateBinaryString(string path)
        {
            using (var image = Injector.Provide<IImageProxy>().LoadImage(path))
            {
                int bitCount = (image.Width * image.Height) / 2;
                logger.Trace("Generating binary string with a length of: [{0}]", bitCount);
                var random = new Random();
                return string.Concat(Enumerable.Range(0, bitCount).Select(i => random.Next(10) % 2 == 0 ? '0' : '1'));
            }
        }

        private void WriteToImage(string path, string binaryData, IInputArguments arguments)
        {
            logger.Trace("Writing binary string to image: [{0}]", path);
            using (var wrapper = new ImageStore(arguments).CreateIOWrapper())
            {
                wrapper.WriteContentChunkToImage(binaryData);
                wrapper.EncodeComplete();
            }
        }

        private string ReadFromImage(string path, string expectedData, IInputArguments arguments)
        {
            logger.Trace("Reading binary string from image: [{0}]", path);
            using (var wrapper = new ImageStore(arguments).CreateIOWrapper())
            {
                return wrapper.ReadContentChunkFromImage(expectedData.Length);
            }
        }
    }
}